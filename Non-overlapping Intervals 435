/**
First we sort the array by below rules

	1) sort by end, smaller end in front
	2) if end is same, sort by start, bigger start in front

Then, visited array by end. If we visited next closest end interval, access the bigger start priority.

Example 1:

Input: [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.
Example 2:

Input: [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.
Example 3:

Input: [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.*/

public int eraseOverlapIntervals(int[][] intervals) {
		Arrays.sort(intervals, (a, b) -> a[1] - b[1]);
		if (intervals == null || intervals.length == 0) return 0;
		int end = intervals[0][1];
		int cnt = 1;
		for (int i = 0; i < intervals.length; i++) {
			if (intervals[i][0] >= end) {
				end = intervals[i][1];
				cnt++;
			}
		}
		return intervals.length - cnt;
	}
